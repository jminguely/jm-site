"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _plugin() {
  const data = require("@parcel/plugin");

  _plugin = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@parcel/utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _xmldom() {
  const data = require("@xmldom/xmldom");

  _xmldom = function () {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = new (_plugin().Packager)({
  async package({
    bundle,
    bundleGraph,
    getInlineBundleContents
  }) {
    const assets = [];
    bundle.traverseAssets(asset => {
      assets.push(asset);
    });

    _assert().default.strictEqual(assets.length, 1, 'XML bundles must only contain one asset');

    let asset = assets[0];
    let code = await asset.getCode();
    let parser = new (_xmldom().DOMParser)();
    let dom = parser.parseFromString(code);
    let inlineElements = dom.getElementsByTagNameNS('https://parceljs.org', 'inline');

    if (inlineElements.length > 0) {
      for (let element of Array.from(inlineElements)) {
        let key = element.getAttribute('key');
        let type = element.getAttribute('type');
        const newContent = await getAssetContent(bundleGraph, getInlineBundleContents, key);

        if (newContent === null) {
          continue;
        }

        let contents = await (0, _utils().blobToString)(newContent.contents);

        if (type === 'xhtml' || type === 'xml') {
          let parsed = new (_xmldom().DOMParser)().parseFromString(contents, 'application/xml');
          element.parentNode.removeChild(element);
          element.parentNode.appendChild(parsed.documentElement);
        } else {
          element.parentNode.textContent = contents;
        }
      }

      code = new (_xmldom().XMLSerializer)().serializeToString(dom);
    }

    const {
      contents,
      map
    } = (0, _utils().replaceURLReferences)({
      bundle,
      bundleGraph,
      contents: code,
      relative: false,
      getReplacement: contents => contents.replace(/"/g, '&quot;')
    });
    return (0, _utils().replaceInlineReferences)({
      bundle,
      bundleGraph,
      contents,
      getInlineBundleContents,
      getInlineReplacement: (dep, inlineType, contents) => ({
        from: dep.id,
        to: contents.replace(/"/g, '&quot;').trim()
      }),
      map
    });
  }

});

exports.default = _default;

async function getAssetContent(bundleGraph, getInlineBundleContents, assetId) {
  let inlineBundle;
  bundleGraph.traverseBundles((bundle, context, {
    stop
  }) => {
    const entryAssets = bundle.getEntryAssets();

    if (entryAssets.some(a => a.uniqueKey === assetId)) {
      inlineBundle = bundle;
      stop();
    }
  });

  if (!inlineBundle) {
    return null;
  }

  const bundleResult = await getInlineBundleContents(inlineBundle, bundleGraph);
  return {
    bundle: inlineBundle,
    contents: bundleResult.contents
  };
}